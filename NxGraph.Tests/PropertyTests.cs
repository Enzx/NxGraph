using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using FsCheck;
// ReSharper disable once RedundantUsingDirective
using FsCheck.NUnit;
using NxGraph.Authoring;
using NxGraph.Diagnostics.Export;
using NxGraph.Diagnostics.Validations;
using NxGraph.Fsm;
using NxGraph.Graphs;
using NxGraph.Serialization;
using NxGraph.Serialization.Abstraction;
using Property = FsCheck.NUnit.PropertyAttribute;

namespace NxGraph.Tests;
#pragma warning disable NUnit1027

[TestFixture]
[Category("property")]
public class PropertyTests
{
    [SuppressMessage("Structure",
        "NUnit1027:The test method has parameters, but no arguments are supplied by attributes",
        Justification = "Arguments are generated by FsCheck")]
    [Property(MaxTest = 100)]
    public bool Director_branching_should_not_create_cycles_without_terminal_nodes(NonNegativeInt depth)
    {
        int n = Math.Min(depth.Get, 5);
        StateToken token = GraphBuilder.StartWith(_ => ResultHelpers.Success);
        GraphBuilder builder = token.Builder;
        for (int i = 0; i < n; i++)
        {
            token = token
                .If(() => true)
                .Then(_ => ResultHelpers.Success)
                .Else(_ => ResultHelpers.Success)
                .WaitFor(TimeSpan.Zero);
        }

        Graph graph = token.Build();
        GraphValidationResult res = graph.Validate(new GraphValidationOptions
        {
            AllNodes = builder.GetAllNodeIds(),
            StrictNoTerminalPath = true
        });
        return !res.HasErrors;
    }

    [Property(MaxTest = 30)]
    public async Task<bool> Serialization_roundtrip_preserves_graph(string[] labels)
    {
        if (labels.Length == 0 || labels.Any(string.IsNullOrWhiteSpace))
        {
            return true;
        }

        GraphSerializer serializer = new(new DummyLogicTextCodec());
        StateToken token = GraphBuilder.StartWith(new DummyState { Data = labels[0] });
        for (int i = 1; i < labels.Length; i++)
        {
            token = token.To(new DummyState { Data = labels[i] });
        }

        Graph graph = token.Build();
        using MemoryStream ms = new();
        await serializer.ToJsonAsync(graph, ms).ConfigureAwait(false);
        string json = System.Text.Encoding.UTF8.GetString(ms.ToArray());
        Console.WriteLine(json);
        ms.Position = 0;
        Graph round = await serializer.FromJsonAsync(ms);
        bool nodesOk = labels.Length == round.NodeCount &&
                       Enumerable.Range(0, labels.Length).All(i =>
                       {
                           INode n = graph.GetNodeByIndex(i);
                           LogicNode logicNode = (LogicNode)n;
                           DummyState state = (DummyState)logicNode.Logic;
                           string label = labels[i];
                           return state.Data == label;
                       });
        bool transitionsOk = Enumerable.Range(0, labels.Length).All(i =>
        {
            Transition tOrig = graph.GetTransitionByIndex(i);
            Transition tRound = round.GetTransitionByIndex(i);
            return tOrig.IsEmpty == tRound.IsEmpty &&
                   (tOrig.IsEmpty || tOrig.Destination.Index == tRound.Destination.Index);
        });
        return nodesOk && transitionsOk;
    }

    [Property(MaxTest = 100)]
    public bool Mermaid_exporter_escapes_names_correctly(NonEmptyString raw)
    {
        string? name = raw.Get;
        if (string.IsNullOrWhiteSpace(name))
            return true;

        StateToken start = GraphBuilder.StartWith(_ => ResultHelpers.Success);
        StateToken node1 = start.To(_ => ResultHelpers.Success).SetName(name);
        Graph graph = node1.Build();

        MermaidExportOptions opts = new()
        {
            UseNodeNames = true,
            ShowNodeIndices = true,
            AddTerminalNode = false
        };

        string mmd = new MermaidGraphExporter().Export(graph, opts)
            .Replace("\r\n", "\n")
            .Replace("\r", "\n");

        string escaped = name.Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\r\n", "\n")
            .Replace("\r", "\n");

        string expected = $"n1[\"{escaped} [1]\"]";

        return mmd.Contains(expected);
    }
}

internal class DummyState : ILogic
{
    public string Data { get; init; } = string.Empty;
   

    public ValueTask<Result> ExecuteAsync(CancellationToken ct = default)
    {
        return ResultHelpers.Success;
    }
}

internal class DummyLogicTextCodec : ILogicCodec<string>
{

    public string Serialize(ILogic logic) =>
        JsonSerializer.Serialize((DummyState)logic);

    public ILogic Deserialize(string data) =>
        JsonSerializer.Deserialize<DummyState>(data)
        ?? new DummyState();
}
#pragma warning restore NUnit1027